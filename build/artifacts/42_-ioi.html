<!--
    :title 2011 IOI
	:date Oct 1 2024<br>4:43 PM
    :tag programming ioi contest-logs
-->
<p>Easier contest (by nature of its age) but still
pretty fun. Due to schedule I started around 3 pm
and therefore ended at 8, on both days, so didn't
have much time to writeup each day separately.</p>
[[ENDSUM]]
<br>
<ol>
    <li>Reduced to some sort of quasi-functional graph, and
        it looked like it could be broken into almost-cycles,
        but I couldn't find a smart way to do this. Instead
        just bruteforced for <b>49</b> points.</li><br>
    <li>I couldn't find any approaches much better than tree
        DP storing the smallest-node path of length <b>0..k</b>
        and iterating for each node. This got subtasks 1 and 2,
        theoretically should have gotten subtask 3, but I got
        implementation wrong. (<b>21</b> pts)</li><br>
    <li>Essentially another bruteforce. It turns out that there
        will always be an optimal position situated exactly at
        one field, and I pretty much iterated over all positions.
        This got <b>68</b> points, for a day 1 total of <b>138</b>.
    </li><br><br>
    <li>Fun question. Tree case was, after a little bit of
        observation, a leaf-contraction sort of thing, and then
        for graph I decided that surely this could be modeled as
        relaxing nodes in an undirected graph, and so use spfa.
        I didn't entirely prove the complexity of this, but it
        sort of made sense. (repeated relaxation of a node would
        <i>probably</i> imply closely connected graph.) Either
        way, it got <b>AC</b>.</li><br>
    <li>Bruteforce with decently good constant factors was enough
        to get <b>50</b> points. Tried working out some segtree/sqrt
        to speed up, but couldn't get anything in time.</li><br>
    <li>Pretty fun question! My first approach was to dedicate
        some <b>x</b> of each packet's 8 bits to store data, and
        the other <b>8-x</b> to store packet # for reconstruction.
        To transmit <b>n</b> bits of data using this protocol,
        <b>n/x</b> packets would need to be sent, and this would
        need to be within the limit of <b>2^(8-x)</b>.<br><br>
        While this was sufficient for subtasks 1..3, it failed on
        4 and above even with <b>x = 1</b>. I realized that the
        limiting factor here was numbering each packet individually.
        <br><br>My new approach was to break up the input data into
        sections of <b>3</b> bits. Each section would correspond to a
        specific bit position on a set of <b>7</b> packets: Counting the
        number of set bits across all <b>7</b> packets, a <b>3</b>-bit number
        which corresponded to the original <b>3</b> bits. Since these <b>8</b>
        packets didn't need to be ordered, I was able to (for subtask
        4) get away with using 5 bits of addressing space and the
        remaining 3 bits for this overlay encoding. For subtask 5,
        where n could be <b>64</b>, I had to use 6 bits of address
        space and 2 bits for encoding, and instead store 4 virtual
        bits in each encoding. This meant that each input number
        corresponded to exactly <b>15</b> packets of transfer, which
        was worth exactly <b>1</b> point, for a problem total of
        <b>82</b> points, a day 2 total of <b>232</b>, and an overall
        total of <b>370</b>.
</ol>
<br>
<p>Funnily, the <b>1</b> point on p6 task 5 was actually significant,
because silver cutoff in 2011 was exactly <b>370</b>. So this
is I guess the second silver like I've hit, although still too close
(and too old of a contest) to really count as a modern-day IOI
silver performance.</p>
